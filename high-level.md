# High level talk plan

## Goals

The audience will come away with:

- A comprehensive understanding of the inner workings of the Y Combinator
- An intuitive understanding of the Y Combinator at a high level
- Working examples of how to solve recursive problems using the Y Combinator

## Audience

This talk should appeal to people who:

- Have never heard of the Y Combinator before
- Have heard of it but not looked into it
- Have looked into it and found it tough to figure out
- Understand it well and want to feel smart about themselves?

An understanding of functional programming is assumed. Experience with (or expose to) Clojure or other Lisps is helpful, but not required.


## Part 1 - intro and primer

- who am I?
- what is the Y Combinator?
- definition
- source code
- example usage
- what it is used for
- Clojure primer

## part 2 - self application of self application

- back to Y combiantor
- self application^2
- <animation>
- back to Y combinator
- wrapped self-application^2
- <animation>

## Part 3 - final pieces

- delayed evaluation lambda

- what is f?
- use f chain to solve problems
- <animation>?
- outro, reading


# TODO:

- make demo for final `count` example
- make slides for final example
- practice
- practice with second screen, presentation mode, tabbing out to animations


# feeback

- @DONE currently 14 minutes, need to slow down, pause for jokes
- always get to the DEMO slide before tabbing out
- double down on reminding us that `f` has not been defined yet
- remove @TODO add comments form second y combinator slide
- count-step not step-count in finale evaluation
- use inc in what the f slides
- say come talk to me again at the end
- initial example usage.js should be clearer that Y is the Y combinator

- can you send fullscreeen to second display in quil????
- email them asking about the resolution of the projectors???
- make animations dependant on screen size
- re-record demo videos (use real software, not image dumping)
- add button/link to demo slides to watch them in another tab

- submit question:
  - why have you chosen to do this in clojure? lisp is a AST, evluationin place is very natural, also I love clojure come see me after.
  - why have you chosen to do this at all? I wrote my first lisp, I thought it would be fun to use it to write another lisp, byt now I had no state or mutation, Y combinatoor only option. I was annoyed that it worked firs try without me needing to understand it.


- 19:07
